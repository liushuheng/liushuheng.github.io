<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>排序算法总结 | carey</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="算法老是看了后面的忘了前面的，脑壳疼 还是写个总结，记下来，没空多翻翻吧== 目前学了的排序（sort）总共有七种：直接插入排序、简单选择排序、冒泡排序、希尔排序、堆排序、快速排序和归并排序 前面三种看名字就比较傻，属于简单算法，后面四种属于改进算法 从操作来分类的话，直接插入和希尔排序都属于插入排序，简单选择和堆排序都属于选择排序，冒泡和快速排序都属于交换排序，归并排序单属归并排序 前面三种大概">
<meta name="keywords" content="算法 、 数据结构">
<meta property="og:type" content="article">
<meta property="og:title" content="排序算法总结">
<meta property="og:url" content="http://yoursite.com/2017/04/26/排序/index.html">
<meta property="og:site_name" content="carey">
<meta property="og:description" content="算法老是看了后面的忘了前面的，脑壳疼 还是写个总结，记下来，没空多翻翻吧== 目前学了的排序（sort）总共有七种：直接插入排序、简单选择排序、冒泡排序、希尔排序、堆排序、快速排序和归并排序 前面三种看名字就比较傻，属于简单算法，后面四种属于改进算法 从操作来分类的话，直接插入和希尔排序都属于插入排序，简单选择和堆排序都属于选择排序，冒泡和快速排序都属于交换排序，归并排序单属归并排序 前面三种大概">
<meta property="og:updated_time" content="2017-04-27T07:55:40.391Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="排序算法总结">
<meta name="twitter:description" content="算法老是看了后面的忘了前面的，脑壳疼 还是写个总结，记下来，没空多翻翻吧== 目前学了的排序（sort）总共有七种：直接插入排序、简单选择排序、冒泡排序、希尔排序、堆排序、快速排序和归并排序 前面三种看名字就比较傻，属于简单算法，后面四种属于改进算法 从操作来分类的话，直接插入和希尔排序都属于插入排序，简单选择和堆排序都属于选择排序，冒泡和快速排序都属于交换排序，归并排序单属归并排序 前面三种大概">
  
    <link rel="alternate" href="/atom.xml" title="carey" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">carey</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-排序" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/26/排序/" class="article-date">
  <time datetime="2017-04-26T13:26:17.000Z" itemprop="datePublished">2017-04-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      排序算法总结
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>算法老是看了后面的忘了前面的，脑壳疼</p>
<p>还是写个总结，记下来，没空多翻翻吧==</p>
<p>目前学了的排序（sort）总共有七种：直接插入排序、简单选择排序、冒泡排序、希尔排序、堆排序、快速排序和归并排序</p>
<p>前面三种看名字就比较傻，属于简单算法，后面四种属于改进算法</p>
<p>从操作来分类的话，直接插入和希尔排序都属于插入排序，简单选择和堆排序都属于选择排序，冒泡和快速排序都属于交换排序，归并排序单属归并排序</p>
<p>前面三种大概说下算法思想，代码就不贴了</p>
<p><strong>直接插入排序（Straight Insertion Sort)</strong>：其基本操作就是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数+1的有序表。直接插入排序一般情况下是简单排序中性能最好的。</p>
<p>在《算法》书中，直接插入排序的算法是将要插入的元素a[i]与数组中所有比它小的元素依次有序交换 </p>
<pre><code>`for (int j=i;j&gt;0&amp;&amp;less(a[j],a[j-1]);j--)
 exch(a,j,j-1);
</code></pre><p>而在《大话数据结构》中，是将a[i]直接插入到指定位置，后面元素依次后移。简化了交换次数，大大提高了效率。（当然，此方法在《算法》中以习题形式给出)</p>
<pre><code>a[0]=a[i];

for (j=i-1;a[j]&gt;a[0];j--)

a[j+1]=a[j]; //记录后移

a[j+1]=a[0];`
</code></pre><hr>
<p><strong>简单选择排序（Simple Selection Sort）</strong>:在数组中找到最小的那个元素，然后将它和数组中的第一个元素交换位置，重复此步骤</p>
<hr>
<p><strong>冒泡排序(Bubble Sort)</strong>：两两比较相邻记录的关键字，如果反序则交换， 知道没有反序为止。排序中可以加入flag作为标记对算法进行优化，可以避免重复循环判断已经排好序的序列。</p>
<hr>
<p>OK简单算法复习完了 (」゜ロ゜)」</p>
<p><strong>改进算法和简单算法的区别就是，前面三种基础算法的时间复杂度都是n的平方，而改进算法突破了这一限制，提升到了O(nlogn)</strong></p>
<p><strong>希尔排序(Shell Sort)</strong>  希尔排序是突破n的平方这个时间复杂度的第一批算法（所以这就是只有希尔算法是以人名命名的算法的原因吗哈哈）</p>
<p>希尔排序可以说是直接插入排序的升级版，其思路是使数组中任意间隔为h的元素都是有序的。实现方法就是将相距h的元素组成一个子序列，在子序列内分别进行直接插入排序。然后再递减h，循环直到h=1，排序完成。</p>
<p>代码如下</p>
<pre><code>public class Shell
 { 
   public static void sort(Comparable[] a)
    {
      int N=a.length;
      int h=1;
      while (h&lt;N/3)h=3*h+1;
      while (h&gt;=1)
       {
         for (int i=h;i&lt;N;i++)
           {
             for (int j=i;j&gt;=h&amp;&amp;a[j]&lt;a[j-h];j-=h)
                exch(a,j,j-h); //此处采用《算法》中的插入方法，主要因为可以少打几行
           }
           h=h/3;
       }
    }
  }    
</code></pre><hr>
<p><strong>归并排序（Merging Sort)</strong>:是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。</p>
<p>归并两个有序序列a b的思想是，比较a[i]和a[j]的大小，若a[i]≤a[j]，则将第一个有序表中的元素a[i]复制到r[k]中，并令i和k分别加上1；否则将第二个有序表中的元素a[j]复制到r[k]中，并令j和k分别加上1，如此循环下去，直到其中一个有序表取完，然后再将另一个有序表中剩余的元素复制到r中从下标k到下标t的单元。</p>
<p>归并算法分为两种：自顶向下和自底向上，，后者较前者代码更为简洁，理解起来也更加方便，而且不需要大量递归调用。自底向上的归并算法代码如下</p>
<pre><code>void MergeSort2(SqList *L)
      {
int* TR=(int*)malloc(L-&gt;length * sizeof(int));/* 申请额外空间 */
int k=1;
while(k&lt;L-&gt;length)
            {
    MergePass(L-&gt;r,TR,k,L-&gt;length);
    k=2*k;/* 子序列长度加倍 */
    MergePass(TR,L-&gt;r,k,L-&gt;length);
    k=2*k;/* 子序列长度加倍 */       
            }
     }  //迭代

/* 将SR[]中相邻长度为s的子序列两两归并到TR[] */
`void MergePass(int SR[],int TR[],int s,int n)
{
int i=1;
int j;
while(i &lt;= n-2*s+1)
  {/* 两两归并 */
    Merge(SR,TR,i,i+s-1,i+2*s-1);
    i=i+2*s;        
  }
if(i&lt;n-s+1) /* 归并最后两个序列 */
    Merge(SR,TR,i,i+s-1,n);
else /* 若最后只剩下单个子序列 */
    for(j =i;j &lt;= n;j++)
        TR[j] = SR[j];
}`

/* 将有序的SR[i..m]和SR[m+1..n]归并为有序的TR[i..n] */
void Merge(int SR[],int TR[],int i,int m,int n)
{
int j,k,l;
for(j=m+1,k=i;i&lt;=m &amp;&amp; j&lt;=n;k++)    /* 将SR中记录由小到大地并入TR */
{
    if (SR[i]&lt;SR[j])
        TR[k]=SR[i++];
    else
        TR[k]=SR[j++];
}
if(i&lt;=m)
{
    for(l=0;l&lt;=m-i;l++)
        TR[k+l]=SR[i+l];        /* 将剩余的SR[i..m]复制到TR */
}
if(j&lt;=n)
{
    for(l=0;l&lt;=n-j;l++)
        TR[k+l]=SR[j+l];        /* 将剩余的SR[j..n]复制到TR */
}
}
</code></pre><hr>
<p><strong>快速排序(Quick sort)</strong>：快速排序的基本思想是通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分关键字小，再分别对这两部分记录递归再分割直至整个数组有序。</p>
<pre><code>void QuickSort(SqList *L)
{ 
QSort(L,1,L-&gt;length);
}

void QSort(SqList *L,int low,int high)
{ 
int pivot;
if(low&lt;high)
{
        pivot=Partition(L,low,high); /*  将L-&gt;r[low..high]一分为二，算出枢轴值pivot */
        QSort(L,low,pivot-1);        /*  对低子表递归排序 */
        QSort(L,pivot+1,high);        /*  对高子表递归排序 */
}

int Partition(SqList *L,int low,int high)
{ 
int pivotkey;

pivotkey=L-&gt;r[low]; /* 用子表的第一个记录作枢轴记录 */
while(low&lt;high) /*  从表的两端交替地向中间扫描 */
{ 
     while(low&lt;high&amp;&amp;L-&gt;r[high]&gt;=pivotkey)
        high--;
     swap(L,low,high);/* 将比枢轴记录小的记录交换到低端 */
     while(low&lt;high&amp;&amp;L-&gt;r[low]&lt;=pivotkey)
        low++;
     swap(L,low,high);/* 将比枢轴记录大的记录交换到高端 */
}
return low; /* 返回枢轴所在位置 */
}
</code></pre><p>改进快速排序，可采用“三数取中法”，即取三个关键字先进行排序，将中间数作为枢轴，一般取左端、右端和中间三个数，也可以随机选取。</p>
<p>当然，上面的简单排序算法还可以继续优化，可以用替代取代交换（类似插入算法的优化），还可以对Qsort实施尾递归优化，即</p>
<pre><code>Qsort(L,low,pivot-1);low=pivot+1;
</code></pre><p>还可以在快速排序中插入一个判断数组大小的语句，当数组较小时使用直接插入排序，只在数组较大时使用快速排序。（数组较小时直接插入排序性能最好）</p>
<hr>
<p><strong>堆排序(Heap Sort)</strong>：堆排序的基本思想是将待排序列构建一个大顶堆。然后将堆的根节点（堆上的最大值）移走，重复此步骤。<br>大顶堆是一种完全二叉树，其上的每个节点的值都大于或等于其左右孩子节点的值。</p>
<p>具体以排序代码如下</p>
<pre><code> void HeapSort(SqList *L)
{
int i;
for(i=L-&gt;length/2;i&gt;0;i--) /*  把L中的r构建成一个大根堆 */
     HeapAdjust(L,i,L-&gt;length);

for(i=L-&gt;length;i&gt;1;i--)
{ 
     swap(L,1,i); /* 将堆顶记录和当前未经排序子序列的最后一个记录交换 */
     HeapAdjust(L,1,i-1); /*  将L-&gt;r[1..i-1]重新调整为大根堆 */
}
}

/* 已知L-&gt;r[s..m]中记录的关键字除L-&gt;r[s]之外均满足堆的定义， */
/* 本函数调整L-&gt;r[s]的关键字,使L-&gt;r[s..m]成为一个大顶堆 */
void HeapAdjust(SqList *L,int s,int m)
{ 
int temp,j;
temp=L-&gt;r[s];
for(j=2*s;j&lt;=m;j*=2) /* 沿关键字较大的孩子结点向下筛选 */
{
    if(j&lt;m &amp;&amp; L-&gt;r[j]&lt;L-&gt;r[j+1])
        ++j; /* j为关键字中较大的记录的下标 */
    if(temp&gt;=L-&gt;r[j])
        break; /* rc应插入在位置s上 */
    L-&gt;r[s]=L-&gt;r[j];
    s=j;
}
L-&gt;r[s]=temp; /* 插入 */
}
</code></pre><hr>
<p>终于都敲完了==<br>总结一下，唉其实也没啥总结的<br>毕竟也只贴了下代码，关于时间复杂度、算法的性能啥都没介绍<br>就将书上的总结搬点上来吧==</p>
<p>1.希尔排序，堆排序和快速排序都是不稳定的（不稳定是指原本相等的两个数，排序后位置可能不相同）</p>
<p>2.性能方面，平均来看，后三种改进算法都要强于希尔排序，远胜于简单算法。但从最好的情况下（即带排序数组基本有序）来看，反而冒泡和直接插入更胜一筹。从最坏情况来看，堆排序和归并排序又强于快速排序以及其他简单算法。</p>
<p>3.从稳定性上来看，归并排序独占鳌头。其次是堆排序。</p>
<p>4.从待排序记录个数来说，个数越小，采用简单算法更合适。这也是在对快速排序优化时，增加一个阀值判断。</p>
<p>大概就这些了</p>
<p>然后说一点自己的体会，不一定正确</p>
<p>就是在处理大量数组时，利用树的结构往往能很大程度上优化算法。几种改进算法都直接或间接地利用了树的结构(把排序过程图画出来就会很容易看出）</p>
<p>好吧，这就是句废话，不然要树干嘛==</p>
<p>这是一个时间戳：2017/4/27 15:49:00 </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/26/排序/" data-id="cj2047jwy00003sw39vgxwv9y" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法-、-数据结构/">算法 、 数据结构</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/04/25/第一篇/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          YESTERDAY YOU SAID TOMORROW
        
      </div>
    </a>
  
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/later-equals-never/">later equals never</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法-、-数据结构/">算法 、 数据结构</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/later-equals-never/" style="font-size: 10px;">later equals never</a> <a href="/tags/算法-、-数据结构/" style="font-size: 10px;">算法 、 数据结构</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/04/26/排序/">排序算法总结</a>
          </li>
        
          <li>
            <a href="/2017/04/25/第一篇/">YESTERDAY YOU SAID TOMORROW</a>
          </li>
        
          <li>
            <a href="/2017/04/14/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 liushuheng<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>